<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Genesis - Refined Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; user-select: none; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; gap: 20px; color: white; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #overlay { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        #msg { color: #ffcc00; font-size: 50px; margin-bottom: 30px; font-weight: bold; }
        button { padding: 15px 50px; font-size: 20px; cursor: pointer; background: #ffcc00; border: none; border-radius: 50px; font-weight: bold; pointer-events: auto; }

        /* 가상 패드 스타일 */
        #virtual-pad {
            position: absolute; width: 80px; height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: none; transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #pad-knob {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="msg">GENESIS</div>
        <button id="start-button" disabled>로딩 중...</button>
    </div>
    <div id="ui-container">
        <div id="hud">
            <div id="score-display">SCORE: 0</div>
            <div id="hp-display">HP: 10</div>
        </div>
        <div id="virtual-pad"><div id="pad-knob"></div></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let gameActive = false, score = 0, playerHP = 10, isInvincible = false;
        let enemies = [], projectiles = [], enemyProjectiles = [], items = [];
        let shootTimer = 0, shootInterval = 900;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // 로드 및 도로 생성
        const roadWidth = 14;
        const road = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, 2000), new THREE.MeshStandardMaterial({ color: 0x444444 }));
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        const loader = new GLTFLoader();
        let sharedModelRaw;
        loader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
            sharedModelRaw = gltf.scene;
            const playerModel = sharedModelRaw.clone();
            playerModel.scale.set(0.35, 0.35, 0.35);
            playerModel.rotation.y = Math.PI;
            playerGroup.add(playerModel);
            document.getElementById('start-button').disabled = false;
            document.getElementById('start-button').innerText = "게임 시작";
        });

        // --- 조작 시스템 (Relative Drag) ---
        let isDragging = false, startX = 0, currentX = 0, moveDir = 0;
        const pad = document.getElementById('virtual-pad');
        const knob = document.getElementById('pad-knob');

        const onStart = (x, y) => {
            if (!gameActive) return;
            isDragging = true; startX = x;
            pad.style.display = 'block';
            pad.style.left = x + 'px'; pad.style.top = y + 'px';
            knob.style.left = '50%';
        };
        const onMove = (x) => {
            if (!isDragging) return;
            currentX = x;
            let diff = currentX - startX;
            let constrainedDiff = Math.max(-40, Math.min(40, diff));
            knob.style.left = (50 + (constrainedDiff / 40) * 50) + '%';
            moveDir = diff > 5 ? 1 : (diff < -5 ? -1 : 0);
        };
        const onEnd = () => { isDragging = false; moveDir = 0; pad.style.display = 'none'; };

        window.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => onMove(e.clientX));
        window.addEventListener('mouseup', onEnd);
        window.addEventListener('touchstart', e => onStart(e.touches[0].clientX, e.touches[0].clientY));
        window.addEventListener('touchmove', e => onMove(e.touches[0].clientX));
        window.addEventListener('touchend', onEnd);

        // --- 게임 기능 ---
        function spawnEnemy() {
            if (!gameActive || !sharedModelRaw) return;
            const enemyGroup = new THREE.Group();
            const enemyModel = sharedModelRaw.clone();
            enemyModel.scale.set(0.35, 0.35, 0.35);
            enemyModel.traverse(c => { if(c.isMesh) { c.material = c.material.clone(); c.material.color.set(0xff5555); }});
            enemyGroup.add(enemyModel);
            enemyGroup.position.set((Math.random()-0.5)*(roadWidth-2), 0, playerGroup.position.z-80);
            scene.add(enemyGroup);
            enemies.push({ mesh: enemyGroup, lastShot: performance.now() + Math.random()*2000 });
        }

        function enemyShoot(enemyPos) {
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            ball.position.set(enemyPos.x, 1.5, enemyPos.z);
            scene.add(ball);
            enemyProjectiles.push(ball);
        }

        function takeDamage(amt) {
            if (isInvincible || !gameActive) return;
            playerHP -= amt;
            document.getElementById('hp-display').innerText = `HP: ${playerHP}`;
            if (playerHP <= 0) { gameActive = false; document.getElementById('msg').innerText = "GAME OVER"; document.getElementById('overlay').style.display = 'flex'; }
            else { isInvincible = true; setTimeout(() => isInvincible = false, 1000); }
        }

        document.getElementById('start-button').addEventListener('click', () => {
            location.reload(); // 단순화를 위한 리로드
        });

        function animate() {
            requestAnimationFrame(animate);
            if (gameActive) {
                playerGroup.position.z -= 0.18;
                // 좌우 속도 절반으로 조정 (0.28 -> 0.14)
                if (moveDir !== 0) playerGroup.position.x += moveDir * 0.14;
                playerGroup.position.x = Math.max(-6.3, Math.min(6.3, playerGroup.position.x));

                camera.position.set(playerGroup.position.x * 0.5, 8, playerGroup.position.z + 10);
                camera.lookAt(playerGroup.position.x, 0, playerGroup.position.z - 10);

                // 플레이어 공격
                if (performance.now() - shootTimer > shootInterval) {
                    const p = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
                    p.position.set(playerGroup.position.x, 1, playerGroup.position.z);
                    scene.add(p); projectiles.push(p); shootTimer = performance.now();
                }

                // 적 로직 (이동 및 공격)
                enemies.forEach((e, idx) => {
                    e.mesh.position.z += 0.05;
                    if (performance.now() - e.lastShot > 3000) {
                        enemyShoot(e.mesh.position);
                        e.lastShot = performance.now();
                    }
                    if (playerGroup.position.distanceTo(e.mesh.position) < 1.5) takeDamage(1);
                });

                // 아군 총알 이동
                projectiles.forEach((p, i) => {
                    p.position.z -= 0.8;
                    enemies.forEach((e, ei) => {
                        if (p.position.distanceTo(e.mesh.position) < 1.5) {
                            scene.remove(e.mesh); enemies.splice(ei, 1);
                            scene.remove(p); projectiles.splice(i, 1);
                            score++; document.getElementById('score-display').innerText = `SCORE: ${score}`;
                        }
                    });
                });

                // 적군 총알 이동 및 충돌
                enemyProjectiles.forEach((eb, i) => {
                    eb.position.z += 0.4;
                    if (eb.position.distanceTo(playerGroup.position) < 1.5) {
                        takeDamage(1); scene.remove(eb); enemyProjectiles.splice(i, 1);
                    }
                    if (eb.position.z > playerGroup.position.z + 10) { scene.remove(eb); enemyProjectiles.splice(i, 1); }
                });

                road.position.z = playerGroup.position.z - 500;
            }
            renderer.render(scene, camera);
        }
        setInterval(spawnEnemy, 2000);
        animate();
    </script>
</body>
</html>